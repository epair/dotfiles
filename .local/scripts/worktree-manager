#!/usr/bin/env bash

# Expects worktree directory to contain a .bare directory and an optional .worktree-setup post install script
# (assumes using git-clone-bare-for-worktrees script)
# Example worktree directory structure:
# .bare
# main
# new-awesome-feature
# hotfix-bug-12
# ...
#
#
# Examples of call:
# worktree-manager add feature-branch
# => Adds a worktree named feature-branch that's attached to a branch named ep/feature-branch
#
# WORKTREE_PREFIX='' worktree-manager add feature-branch
# => Adds a worktree named feature-branch that's attached to a branch named feature-branch
#
# worktree-manager add remote-branch
# => Fetches a branch named ep/remote-branch and creates a worktree reference to it
#
# worktree-manager remove feature-branch
# => Deletes a worktree named feature-branch that's attached to a branch named ep/feature-branch

if [ -z "${WORKTREE_PREFIX+x}" ]; then
    echo "no worktree prefix"
    echo "using ep/"
    WORKTREE_PREFIX='ep/'
fi

if [[ -d .bare ]]; then
  parent_dir=$(pwd)
elif [[ -d ../.bare ]]; then
  parent_dir=$(cd .. && pwd)
else
  echo "current directory is not a git worktree"
  exit 1
fi

while [[ $# -gt 0 ]]; do
  if [[ $1 == "add" || $1 == "remove" ]]; then
    command="$1"
  else
    worktree_name="$1"
  fi
  shift
done

worktree_dir="$parent_dir/$worktree_name"
branch_name="$WORKTREE_PREFIX$worktree_name"

setup_worktree_env() {
  if [[ -x "$parent_dir/.worktree-setup" ]]; then
    "$parent_dir/.worktree-setup" "$worktree_dir"
  fi
}

if [[ "$command" == "add" && -n "$worktree_name" ]]; then
  if git show-ref --verify --quiet "refs/remotes/origin/$branch_name"; then
    git fetch origin "$branch_name:$branch_name"
  else
    git fetch origin main:main
    git branch "$branch_name" main > /dev/null 2>&1
  fi
  git worktree add "$worktree_dir" "$branch_name" > /dev/null 2>&1
  setup_worktree_env
elif [[ "$command" == "remove" && -n "$worktree_name" ]]; then
  echo "Removing worktree: $worktree_name"
  echo "Worktree dir: $worktree_dir"
  echo "Current dir: $(pwd)"
  
  # Change to the parent directory where .bare is located
  cd "$parent_dir" || exit 1
  
  # First, check if the worktree is registered with git
  if git worktree list | grep -q "$worktree_name"; then
    echo "Worktree is registered with git, removing..."
    git worktree remove --force "$worktree_name" 2>&1
  else
    echo "Worktree not registered with git"
  fi
  
  # Clean up the directory if it still exists
  if [[ -d "$worktree_dir" ]]; then
    echo "Directory still exists at: $worktree_dir"
    
    # First try without sudo
    if rm -rf "$worktree_dir" 2>/dev/null; then
      echo "Directory removed successfully"
    else
      echo "Need elevated permissions to remove directory"
      
      # Check if we're in a tmux session
      if [[ -n "$TMUX" ]]; then
        # Use tmux to prompt for sudo password
        tmux display-message "Removing worktree directory requires sudo access..."
        tmux run-shell "sudo rm -rf '$worktree_dir'"
      else
        # Regular sudo if not in tmux
        sudo rm -rf "$worktree_dir"
      fi
      
      # Verify removal
      if [[ -d "$worktree_dir" ]]; then
        echo "ERROR: Failed to remove directory!"
        exit 1
      else
        echo "Directory removed with elevated permissions"
      fi
    fi
  fi
  
  # Prune any stale worktree entries
  git worktree prune
  
  # Remove the branch if it exists
  echo "Removing branch: $branch_name"
  git branch -D "$branch_name" 2>&1 || echo "Branch '$branch_name' doesn't exist"
else
  echo 'either no command or branch name specified'
  exit 1
fi
